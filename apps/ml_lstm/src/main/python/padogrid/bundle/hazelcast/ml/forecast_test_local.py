"""
Copyright (c) 2023 Netcrest Technologies, LLC. All rights reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
"""

'''
Created on July 12, 2023

Tests HazelcastLstmDna by fetching data from the grid and running LSTM locally. 
This test requires the mock data generated by the following bundle.

   bundle-none-app-simulator
   
Run this program if

  - You need to generate a new model.
  - You want to validate the model with the test dataset.

You can change the LSTM and grid parameters in the 'User Inputs' section in this code.
Note that if the 'working_dir" parameter is not set then it assumes you are running
Hazelcast in PadoGrid and defaults to "$PADOGRID_WORKSPACE/apps/ml_lstm".
    
@author: dpark
'''

import argparse

from padogrid.bundle.hazelcast.dna.hazelcast_lstm_dna import HazelcastLstmDna
from padogrid.bundle.hazelcast.data.PortableFactoryImpl import PortableFactoryImpl
import os
import sys
import hazelcast
from matplotlib import pyplot
import pandas as pd
from sklearn.metrics import r2_score

# Disable CPU warning message
os.environ['TF_CPP_MIN_LOG_LEVEL'] = '2'
        
def plot_forecasts(train_time_list, train_data_list, time_list, expected_list, forecasts, time_type="date", time_delta="1 day"):
    '''
    Plots the specified train and test (expected) datasets in addition to the specified forecasts.
    '''
    
    # Label and plot
    fig, ax = pyplot.subplots(1, figsize=(14, 8))
    fig.suptitle(feature + " LSTM Test Data Validation")
    ax.set(xlabel='Time', ylabel='Value')

    # Plot the entire train data in blue
    ax.plot(train_time_list, train_data_list, color='blue', label="Observed")
    
    # Get the last values in the train list. It is the staring point for plotting
    # the forecasted values.
    xvalue = train_time_list[-1]
    yvalue = train_data_list[-1]
    for i in range(len(forecasts)):
        # The last time value is the starting point of this iteration of forecasted values
        xaxis = [xvalue]
        # Build array with future dates. Increment the time by month.
        
        forecast = forecasts[i]
        time_value = xvalue
        for j in range(len(forecast)):
            if time_type == "date":
                time_value += pd.Timedelta(time_delta)
            else:
                year = time_value.year
                month = time_value.month
                if month % 12 == 0:
                    year += 1
                    month = 1
                else:
                    month += 1
                time_value = pd.Timestamp(year, month, 1)
            xaxis += [time_value] 
        # insert the last value in the yaxis list. The last value is the starting point
        # for this iteration of forecasted values
        yaxis = [yvalue] + expected_list[i]
        # Plot test data in black
        ax.plot(xaxis, yaxis, color='black')
        yaxis = [yvalue] + forecasts[i]
        #Plot forecast data in red
        ax.plot(xaxis, yaxis, color='red')
        xvalue = time_list[i]
        yvalue = expected_list[i][0]
    
    ax.legend(["Observed", "Train", "Forecast"], loc = "upper left")
    fig.canvas.draw()
    fig.canvas.flush_events()

# -------------------------------
# User Inputs
# -------------------------------
parser = argparse.ArgumentParser(description="Plots observed and forecasted data for the specified Hazelcast map. "
    + "It generates an LSTM model for the specified map that contains observed data if the model is not already generated. "
    + "To force generating a model, specify the '--generate' option. It will overwrite the previously generated model.",
                                 formatter_class=argparse.ArgumentDefaultsHelpFormatter)
parser.add_argument("-?", action="store_true", help="show this help message and exit")
parser.add_argument("-m", "--map", default="stocks", help="Hazelcast map that contains observed data")
parser.add_argument("-f", "--feature", default="stock1-jitter", help="Feature name")
parser.add_argument("-g", "--generate", action="store_true", help="Generate model. If specified then creates a new model, otherwise, uses the existing model.")
parser.add_argument("-e", "--epochs", default=10, type=int, help="Number of model fit iterations (number of epochs to train the model). This option has no effect for the existing model.")
parser.add_argument("-n", "--neurons", default=10, type=int, help="Number of neurons in the hidden layer. This option has no effect for the existing model.")
parser.add_argument("-b", "--batch_size", default=1, type=int, help="Batch size. If the existing model is used, then the specified batch size is overwritten with the existing model's batch size.")
parser.add_argument("-t", "--test_data_percentage", default=0.2, type=float, help="Test data percentage.")
parser.add_argument("-v", "--verbose", action="store_true", help="Print interim results.")
args = vars(parser.parse_args())

# '-?' in addition to '-h', '--help'
is_help = args["?"]
if is_help:
    parser.print_help()
    exit()

# grid_path is the name of the Hazelcast map that contains the data.
grid_path = args["map"]
feature = args["feature"]
is_generate = args["generate"]
use_saved_model = is_generate != True
test_data_percentage = args["test_data_percentage"]
if test_data_percentage <= 0 or test_data_percentage >= 1:
    print(f'ERROR: Invalid test_data_percentage {test_data_percentage}', file=sys.stderr)
    exit(1)

# LSTM network parameters
epochs = args["epochs"]
neurons = args["neurons"]
batch_size = args["batch_size"]

is_verbose = args["verbose"]

print()
print("---------------------------------------")
print("                 map: " + str(grid_path))
print("             feature: " + str(feature))
print("            generate: " + str(is_generate))
print("              epochs: " + str(epochs))
print("             neurons: " + str(neurons))
print("          batch_size: " + str(batch_size))
print("test_data_percentage: " + str(test_data_percentage))
print("---------------------------------------")
print()

# Working directory where the model is saved. By default, it assumes you are running
# this program in PadoGrid.
workspace_dir = os.environ['PADOGRID_WORKSPACE']
if workspace_dir == "":
    raise Exception("ERROR: PADOGRID_WORKSPACE environment var is not set. Aborted.")
working_dir = workspace_dir + "/apps/ml_lstm"
if os.path.isdir(working_dir) == False:
    raise Exception("ERROR: working_dir (" + working_dir + ") does not exist. Aborted.")

# -------------------------------
# End of User Inputs
# -------------------------------

# Connect to Jet
client = hazelcast.HazelcastClient(cluster_name="ml_jet", portable_factories=PortableFactoryImpl.factories())

# HazelcastLstmDna expects the Hazelcast map to contain JSON objects with the specified
# numerical feature (attributes).
dna = HazelcastLstmDna(feature, client, working_dir=working_dir, verbose=is_verbose)

# --------------------------------------------------------------------------
# Execute locally
# --------------------------------------------------------------------------

# First, get temporal_list
# --------------------------------------------------------------------------

# Try comparing jitter vs no-jitter. With no-jitter, the simulator generates
# unaltered equation values which should result in high accuracy of predicted
# values.

# ------
# stock1 
# ------
#feature="stock1-jitter"
# R^2=0.92
#feature="stock1-jitter-large"
#feature="stock1-no-jitter"

# ------
# stock2
# ------
#feature="stock2-jitter"
#feature="stock2-no-jitter"

model_name="model_" + feature

where_clause = None
jresult = dna.run_lstm_local(grid_path, where_clause, time_attribute="time",
                            use_saved_model=use_saved_model, model_name=model_name,
                            return_train_data=True,
                            time_type='date',
                            value_key=feature,
                            epochs=epochs,
                            neurons=neurons,
                            batch_size=batch_size,
                            test_data_percentage=test_data_percentage)
# print(jresult)
# --------------------------------------------------------------------------

if jresult != None:
    expected_list = jresult['Expected']
    predicted_list = jresult['Predicted']
    time_list = pd.to_datetime(jresult['Time'])

    if 'TrainData' in jresult:
        train_data_list = jresult['TrainData']
        train_time_list = pd.to_datetime(jresult['TrainTime'])

    plot_forecasts(train_time_list, train_data_list, time_list, expected_list, predicted_list, time_delta="1 day")

    if is_verbose:
        print()
        print("-------------")
        print("expected_list")
        print("-------------")
        print(expected_list)
        print()
        print("--------------")
        print("predicted_list")
        print("--------------")
        print(predicted_list)

    test_data = expected_list[1:2]

    if 'TrainRmse' in jresult:
        train_rmse = jresult['TrainRmse']
        print('RMSE(train)=%f' % train_rmse)
    rmse = jresult['Rmse']
    normalized_rmse = jresult['NormalizedRmse']
    print()
    print(f'RMSE: {rmse}, Normalized RMSE: {normalized_rmse}')
    # Coefficient of determination or variance score: 1 is perfect prediction
    r2 = r2_score(expected_list, predicted_list)
    print('Coefficient of Determination - R^2 score: %.2f' % r2)
    print()

    ## Display and block
    pyplot.gcf().canvas.manager.set_window_title("PadoGrid LSTM Model Validation")
    pyplot.show()

#client.shutdown()